Q.1 The vendor of the attack target is concerned that news of this attack
    could scare off potential customers; they will make any alteration
    necessary (in software or hardware) to prevent the attack.  Explain the
    options they have, and which one you would recommend.

    Option 1: RSA Blinding (Most widely used)
        Message blinding works by the multiplying the input message with a random value, and after exponentiation removing the effect of the random value.
        By introducing a different random value for each message, it prevents an attacker from entering a known input to the exponentiation function.
        This intern makes the resultant timing information unusable. Blinding incurs a small performance penalty in the range of 1-10%

    Option 2: Always-Compute
        This method involves removing connection between the private key and computation time. If we always compute the extra reduction step in the Montgomery algorithm, but only use the result when needed.
        Care may need to be taken to prevent the compiler optimising (removing) this extra calculation when it isn't being used.

    Option 3: Quantize
        This method involves making all computations take a multiple of some predefined time. However, the major drawback to this is performance, all calculations must  must then take the longest of all computation times.

    I would recommend using both option 1 and 2 as they have very minimal overhead. I would avoid using option 3 as it could make computation time much longer, which is not preferable in most large scale systems.

Q.2 The vendor of the attack target is concerned that a similar attack may
    also apply to their implementation of ElGamal encryption.  Explain the
    potential for such an attack, and how it differs wrt.  the case of RSA.

    Both ElGamal and RSA are types of public key encryption schemes, but they differ is their mathematical assumption. ElGamal relies on the hardness of solving discrete logarithms
    whereas RSA relies on the hardness of factoring. This means that there decryption oracles also differ slightly:

    RSA:
        c = < m^e > mod N, public key = < N, e >,
        m = < c^d > mod N, private key = < d >
    ElGamal:
        c = < m * h^y, g^y >   mod q,   public key = < q, g, h >, empirical key: y randomly selected {1,...,q-1}
        m = < c2 * (c1^d)^-1 > mod q,   private key = < d >

    Decryption:
        RSA-Dec:      Input = ( c ),     Computes: m = c^d  mod N, where the d is the private key.
        ElGamal-Dec:  Input = ( c1, c2)  Computes: s = c1^d mod q, m = c2 * s^-1 mod q, where d is the private key


    From the Decryption section we can observer that although RSA and ElGamal perform different operations, they both perform a modular calculations on the message raised to the private exponent d.
    This means that the same attack can be performed on both RSA and ElGamal.


Q.5 The level of noise, n, within measurements of execution time will
    influence the number of measurements, m, required for a successful
    attack.  Explain what the relationship between n and m is (i.e., how
    you expect m to grow as n grows).

    The intuitive relationship is that as the about of noise increases, the number of measurements required for a successful attack also increases. One can imagine that as the noise increases, the timings will
    appear more random. To help filter this randomness we can increase the number of measurements.  If we take the average across all samples, it should make any apparent differences in data more observable.

Q.6 Let n denote the number of simulated clock cycles required to execute a
    Montgomery multiplication on the attack target.  Estimate the value of
    n (as accurately as you can) and explain how you did so.

    To calculate execution time for Montgomery multiplication, I recorded the time for every Montgomery multiplication in the entire attack and calculated the average.
    The timings was taken under a condition with only minimal other processes running at the same time.

    Time to complete Montgomery multiplication (Personal Computer):
        With reduction      : 0.00004757343018893579s
        Without reduction   : 0.00004385970949741723s
        Average             : 0.00004571656984317651s

    Calculation = clock cycles per second * number of seconds for Montgomery multiplication

                      CPU GHz       Cycles per s           n
    Linux Lab Machine:  3.5GHz  =   3,500,000,000   =
    Personal Computer:  4GHz    =   4,000,000,000   =
      PC With Red    :                              =    190294
      PC Without Red :                              =    175439
      PC Average     :                              =    182866


     Answer: n = 182866
